# 👷‍♀️ GitHub Actions Workflow for Python Testing and Code Coverage

      # 🟡 This workflow will run automatically:
      # - when code is pushed to the "main" branch
      # - when a pull request is opened against the "main" branch
      # - unless the change is only to ignored files like markdown, docs, or README

      name: Python application
      
      on:
        push:
          branches: [ "main" ]
          paths-ignore:
            - '**.md'           # Skip running CI if only markdown files change
            - 'docs/**'         # Skip if only docs are updated
            - '**.rst'          # Skip reStructuredText files
            - 'LICENSE'         # Skip license updates
            - '.gitignore'      # Skip gitignore-only changes
            - 'README*'         # Skip README edits
        pull_request:
          branches: [ "main" ]
          paths-ignore:
            - '**.md'
            - 'docs/**'
            - '**.rst'
            - 'LICENSE'
            - '.gitignore'
            - 'README*'
      
      jobs:
        build:  # 🔨 Job name
          runs-on: ubuntu-latest  # 🖥️ This job will run in a virtual machine with Ubuntu
      
          steps:
            # Step 1: Get your code
            - name: Checkout Repository
              uses: actions/checkout@v4
            # 📂 This downloads your repository's files into the CI environment
      
            # Step 2: Set up Python
            - name: Set up Python
              uses: actions/setup-python@v5
              with:
                python-version: "3.13.5"  # Python version must match your local dev environment
      
            # Step 3: Install dependencies
            - name: Install dependencies
              run: |
                python -m pip install --upgrade pip  # Upgrade pip
                pip install -r requirements.txt      # Install all Python packages listed in requirements.txt
      

            # Step 4: Prepare test environment for database integration
            - name: Prepare test environment
              run: |
                # Create writable app/data directory for tests
                mkdir -p app/data
                chmod 755 app/data
                # Ensure no existing database files interfere
                rm -f tasks.db app/data/tasks.json
                echo "Test environment prepared for Sprint 4 database integration"

            # Step 5: Start Flask server for integration tests
            - name: Start Flask server
              run: |
                # Set environment variables for testing
                export TESTING=true
                export PYTHONDONTWRITEBYTECODE=1
                export FLASK_APP=app.main
                export FLASK_ENV=testing
                # Start Flask server in background for API integration tests
                cd $GITHUB_WORKSPACE
                python -c "
                import os
                os.environ['TESTING'] = 'true'
                from app import create_app
                app = create_app()
                print('Database tables created successfully')
                print('Starting Flask server...')
                app.run(host='127.0.0.1', port=5000, debug=False)
                " &
              continue-on-error: true

            # Step 6: Wait for Flask server to be ready (health check loop)
            - name: Wait for Flask server to be ready
              run: |
                for i in {1..20}; do
                  if curl -s http://localhost:5000/api/health > /dev/null; then
                    echo "✅ Flask server is up and responding!"
                    # Also test the API endpoint
                    if curl -s http://localhost:5000/api/tasks > /dev/null; then
                      echo "✅ API endpoint is working!"
                      break
                    else
                      echo "❌ API endpoint not responding"
                    fi
                  fi
                  echo "Waiting for Flask server... (attempt $i/20)"
                  sleep 1
                done
                # Final check
                if curl -s http://localhost:5000/api/health > /dev/null && curl -s http://localhost:5000/api/tasks > /dev/null; then
                  echo "✅ Server health check passed - API tests will run"
                else
                  echo "❌ Server health check failed - API tests will be skipped"
                fi
              continue-on-error: true

            # Step 7: Run tests with coverage tracking  
            - name: Run tests with coverage
              run: |
                # Set environment variables for testing
                export TESTING=true
                export PYTHONDONTWRITEBYTECODE=1
                # Suppress ResourceWarnings for cleaner CI output (these are normal for educational code)
                export PYTHONWARNINGS="ignore:unclosed:ResourceWarning"
                
                # Check if server is working before running tests
                if curl -s http://localhost:5000/api/health > /dev/null && curl -s http://localhost:5000/api/tasks > /dev/null; then
                  echo "✅ Server is working - running all tests including API integration tests"
                  pytest --cov=app --cov-report=term-missing
                else
                  echo "❌ Server not working - running tests excluding live server integration tests"
                  pytest --cov=app --cov-report=term-missing -k "not (test_add_and_get_tasks_end_to_end or test_complete_task_end_to_end or test_delete_task_end_to_end)"
                fi
                #  This runs pytest and measures how much of the 'app' folder is tested
                # --cov=app → tracks coverage in the 'app' directory  
                # --cov-report=term-missing → shows which lines were not tested
                # API tests in tests/api/ have built-in skip logic if server unavailable
      
            # (Optional) Step 5: Enforce a minimum test coverage percentage
            # - name: Enforce minimum coverage
            #   run: |
            #     coverage report --fail-under=80
            #     # ❌ This will fail the build if total coverage is below 80%
      
            # (Optional) Step 6: Save the HTML version of the coverage report as an artifact
            # - name: Upload coverage HTML report
            #   uses: actions/upload-artifact@v3
            #   with:
            #     name: coverage-html
            #     path: htmlcov/
            #     # 📁 This allows you to download and view the full HTML coverage report after CI runs
